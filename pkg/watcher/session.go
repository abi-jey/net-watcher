// Generated by Copilot
package watcher

import (
	"encoding/binary"
	"fmt"
	"net"
	"strings"
	"sync"
	"time"

	"github.com/abja/net-watcher/internal/database"
	"github.com/charmbracelet/log"
)

// Protocol types for session tracking
type Protocol string

const (
	ProtoTCP  Protocol = "TCP"
	ProtoUDP  Protocol = "UDP"
	ProtoICMP Protocol = "ICMP"
)

// Session represents an active connection in memory
type Session struct {
	ID        string
	Protocol  Protocol
	Src       string
	Dst       string
	Iface     string
	IPVersion uint8 // 4 or 6
	StartTime time.Time
	LastSeen  time.Time
	ByteCount int64
	Hostname  string // Cached hostname for this connection
	// DNS specific
	DNSQueries []string
	// TLS specific
	SNI string
}

// DNSCacheEntry stores a resolved hostname with timestamp
type DNSCacheEntry struct {
	Hostname  string
	Timestamp time.Time
}

// SessionManager handles the state of active connections
type SessionManager struct {
	sessions map[string]*Session
	mutex    sync.RWMutex
	logger   *log.Logger
	db       *database.DB
	// Configuration
	cleanupInterval time.Duration
	sessionTimeout  time.Duration
	stopChan        chan struct{}
	// Filters - which protocols/events to log
	filters      map[string]bool
	exclusions   map[string]bool
	excludePorts map[uint16]bool
	// Track recent rejected UDP to combine with ICMP unreachable
	recentUDPRejects     map[string]time.Time
	recentUDPRejectMutex sync.RWMutex
	// DNS cache: IP -> hostname + timestamp
	dnsCache      map[string]*DNSCacheEntry
	dnsCacheMutex sync.RWMutex
}

// NewSessionManager creates a new session manager and starts the cleanup goroutine
// onlyFilter is a comma-separated list of protocols to log (tcp,udp,icmp,dns,tls)
// excludeFilter is a comma-separated list of traffic to exclude
// excludePortsStr is a comma-separated list of ports to exclude
// Empty string means log everything / exclude nothing
func NewSessionManager(logger *log.Logger, db *database.DB, onlyFilter, excludeFilter, excludePortsStr string) *SessionManager {
	filters := parseFilters(onlyFilter)
	exclusions := parseFilters(excludeFilter)
	excludePorts := parsePortsFilter(excludePortsStr)

	// Debug: log excluded ports
	if len(excludePorts) > 0 {
		var ports []uint16
		for p := range excludePorts {
			ports = append(ports, p)
		}
		logger.Info("Excluding ports", "ports", ports)
	}

	sm := &SessionManager{
		sessions:         make(map[string]*Session),
		logger:           logger,
		db:               db,
		cleanupInterval:  30 * time.Second,
		sessionTimeout:   2 * time.Minute,
		stopChan:         make(chan struct{}),
		filters:          filters,
		exclusions:       exclusions,
		excludePorts:     excludePorts,
		recentUDPRejects: make(map[string]time.Time),
		dnsCache:         make(map[string]*DNSCacheEntry),
	}
	// Start Garbage Collector in background
	go sm.cleanupLoop()
	return sm
}

// parseFilters converts comma-separated filter string to a map
func parseFilters(filterStr string) map[string]bool {
	filters := make(map[string]bool)
	if filterStr == "" {
		// Empty means log everything
		return filters
	}
	for _, f := range strings.Split(strings.ToLower(filterStr), ",") {
		f = strings.TrimSpace(f)
		if f != "" {
			filters[f] = true
		}
	}
	return filters
}

// parsePortsFilter converts comma-separated port string to a map
func parsePortsFilter(portsStr string) map[uint16]bool {
	ports := make(map[uint16]bool)
	if portsStr == "" {
		return ports
	}
	for _, p := range strings.Split(portsStr, ",") {
		p = strings.TrimSpace(p)
		if p != "" {
			var port int
			if _, err := fmt.Sscanf(p, "%d", &port); err == nil && port > 0 && port <= 65535 {
				ports[uint16(port)] = true
			}
		}
	}
	return ports
}

// shouldLog returns true if the given protocol should be logged
func (sm *SessionManager) shouldLog(protocol string) bool {
	// If no filters specified, log everything
	if len(sm.filters) == 0 {
		return true
	}
	return sm.filters[strings.ToLower(protocol)]
}

// shouldExclude checks if traffic should be excluded based on src/dst addresses and ports
func (sm *SessionManager) shouldExclude(src, dst string, srcPort, dstPort uint16) bool {
	// Check for explicitly excluded ports first (independent of --exclude flag)
	if len(sm.excludePorts) > 0 {
		if sm.excludePorts[srcPort] || sm.excludePorts[dstPort] {
			return true
		}
	}

	if len(sm.exclusions) == 0 {
		return false
	}

	// Check for multicast exclusion (224.0.0.0/4 for IPv4, ff00::/8 for IPv6)
	if sm.exclusions["multicast"] {
		if isMulticastAddress(dst) {
			return true
		}
	}

	// Check for broadcast exclusion
	if sm.exclusions["broadcast"] {
		if strings.Contains(dst, "255.255.255.255") {
			return true
		}
	}

	// Check for link-local exclusion (169.254.x.x, fe80::)
	if sm.exclusions["linklocal"] {
		if isLinkLocalAddress(src) || isLinkLocalAddress(dst) {
			return true
		}
	}

	// Check for BitTorrent exclusion (common DHT ports)
	if sm.exclusions["bittorrent"] {
		btPorts := map[uint16]bool{
			6881: true, 6882: true, 6883: true, 6884: true, 6885: true,
			6886: true, 6887: true, 6888: true, 6889: true, 6890: true,
			51413: true, // Transmission default
		}
		if btPorts[srcPort] || btPorts[dstPort] {
			return true
		}
	}

	// Check for mDNS exclusion
	if sm.exclusions["mdns"] {
		if srcPort == 5353 || dstPort == 5353 {
			return true
		}
	}

	// Check for SSDP/UPnP exclusion
	if sm.exclusions["ssdp"] {
		if srcPort == 1900 || dstPort == 1900 {
			return true
		}
	}

	// Check for cloud metadata service exclusion (169.254.169.254)
	if sm.exclusions["metadata"] {
		if isMetadataAddress(src) || isMetadataAddress(dst) {
			return true
		}
	}

	return false
}

// isMulticastAddress checks if address is multicast
func isMulticastAddress(addr string) bool {
	// IPv4 multicast: 224.0.0.0 - 239.255.255.255
	// IPv6 multicast: ff00::/8
	if strings.HasPrefix(addr, "[224.") || strings.HasPrefix(addr, "[225.") ||
		strings.HasPrefix(addr, "[226.") || strings.HasPrefix(addr, "[227.") ||
		strings.HasPrefix(addr, "[228.") || strings.HasPrefix(addr, "[229.") ||
		strings.HasPrefix(addr, "[230.") || strings.HasPrefix(addr, "[231.") ||
		strings.HasPrefix(addr, "[232.") || strings.HasPrefix(addr, "[233.") ||
		strings.HasPrefix(addr, "[234.") || strings.HasPrefix(addr, "[235.") ||
		strings.HasPrefix(addr, "[236.") || strings.HasPrefix(addr, "[237.") ||
		strings.HasPrefix(addr, "[238.") || strings.HasPrefix(addr, "[239.") ||
		strings.HasPrefix(addr, "[ff") {
		return true
	}
	return false
}

// isLinkLocalAddress checks if address is link-local
func isLinkLocalAddress(addr string) bool {
	// IPv4 link-local: 169.254.x.x
	// IPv6 link-local: fe80::/10
	if strings.HasPrefix(addr, "[169.254.") || strings.HasPrefix(addr, "[fe80:") ||
		strings.HasPrefix(addr, "169.254.") || strings.HasPrefix(addr, "fe80:") {
		return true
	}
	return false
}

// isMetadataAddress checks if address is cloud metadata service (169.254.169.254)
func isMetadataAddress(addr string) bool {
	return strings.Contains(addr, "169.254.169.254")
}

// Stop stops the session manager cleanup goroutine
func (sm *SessionManager) Stop() {
	close(sm.stopChan)
}

// TrackTCP handles TCP connection state machine
func (sm *SessionManager) TrackTCP(iface, src, dst string, isSyn, isFin, isRst bool, length int, isIPv6 bool) {
	if !sm.shouldLog("tcp") {
		return
	}

	ipVersion := uint8(4)
	if isIPv6 {
		ipVersion = 6
	}

	// Check metadata service exclusion
	if sm.exclusions["metadata"] {
		if isMetadataAddress(src) || isMetadataAddress(dst) {
			return
		}
	}

	// Generate a consistent key for this connection
	key := fmt.Sprintf("TCP:%s->%s", src, dst)

	sm.mutex.Lock()
	defer sm.mutex.Unlock()

	session, exists := sm.sessions[key]

	// CASE A: New Connection (SYN without ACK)
	if isSyn && !exists {
		// Look up hostname from DNS cache
		dstIP := extractIPFromAddr(dst)
		hostname, dnsAge := sm.lookupDNSCache(dstIP)

		sm.sessions[key] = &Session{
			ID:        key,
			Protocol:  ProtoTCP,
			Src:       src,
			Dst:       dst,
			Iface:     iface,
			IPVersion: ipVersion,
			Hostname:  hostname,
			StartTime: time.Now(),
			LastSeen:  time.Now(),
			ByteCount: int64(length),
		}

		srcIP, srcPortNum := parseAddr(src)
		dstIPParsed, dstPortNum := parseAddr(dst)

		// Log and save to DB
		if hostname != "" {
			sm.logger.Info("[TCP START]",
				"iface", iface,
				"src", src,
				"dst", dst,
				"hostname", hostname,
				"dns_age", dnsAge.Round(time.Millisecond),
			)
			if sm.db != nil {
				sm.db.InsertEvent(&database.NetworkEvent{
					Timestamp: time.Now(),
					EventType: database.EventTCPStart,
					Interface: iface,
					IPVersion: ipVersion,
					SrcIP:     srcIP,
					SrcPort:   srcPortNum,
					DstIP:     dstIPParsed,
					DstPort:   dstPortNum,
					Hostname:  hostname,
					DNSAge:    dnsAge.Milliseconds(),
				})
			}
		} else {
			sm.logger.Info("[TCP START]",
				"iface", iface,
				"src", src,
				"dst", dst,
			)
			if sm.db != nil {
				sm.db.InsertEvent(&database.NetworkEvent{
					Timestamp: time.Now(),
					EventType: database.EventTCPStart,
					Interface: iface,
					IPVersion: ipVersion,
					SrcIP:     srcIP,
					SrcPort:   srcPortNum,
					DstIP:     dstIPParsed,
					DstPort:   dstPortNum,
				})
			}
		}
		return
	}

	// CASE B: Existing Connection (Update)
	if exists {
		session.LastSeen = time.Now()
		session.ByteCount += int64(length)

		// CASE C: End of Connection (FIN or RST)
		if isFin || isRst {
			duration := time.Since(session.StartTime)
			endReason := "FIN"
			if isRst {
				endReason = "RST"
			}
			sm.logger.Info("[TCP END]",
				"iface", session.Iface,
				"src", src,
				"dst", dst,
				"duration", duration.Round(time.Millisecond),
				"bytes", session.ByteCount,
				"reason", endReason,
			)

			srcIP, srcPortNum := parseAddr(src)
			dstIP, dstPortNum := parseAddr(dst)
			if sm.db != nil {
				sm.db.InsertEvent(&database.NetworkEvent{
					Timestamp: time.Now(),
					EventType: database.EventTCPEnd,
					Interface: session.Iface,
					IPVersion: session.IPVersion,
					SrcIP:     srcIP,
					SrcPort:   srcPortNum,
					DstIP:     dstIP,
					DstPort:   dstPortNum,
					Hostname:  session.Hostname,
					Duration:  duration.Milliseconds(),
					ByteCount: session.ByteCount,
					Reason:    endReason,
				})
			}
			delete(sm.sessions, key)
		}
	}
}

// TrackUDP handles UDP "connections" using timeout-based tracking
func (sm *SessionManager) TrackUDP(iface, src, dst string, srcPort, dstPort uint16, length int, isIPv6 bool) {
	if !sm.shouldLog("udp") {
		return
	}

	// Check exclusions
	if sm.shouldExclude(src, dst, srcPort, dstPort) {
		return
	}

	ipVersion := uint8(4)
	if isIPv6 {
		ipVersion = 6
	}

	// For UDP, we create bi-directional session keys
	key := fmt.Sprintf("UDP:%s<->%s", src, dst)
	reverseKey := fmt.Sprintf("UDP:%s<->%s", dst, src)

	sm.mutex.Lock()
	defer sm.mutex.Unlock()

	// Check if session exists in either direction
	session, exists := sm.sessions[key]
	if !exists {
		session, exists = sm.sessions[reverseKey]
		if exists {
			key = reverseKey
		}
	}

	if !exists {
		// Identify service based on port
		service := identifyUDPService(srcPort, dstPort)

		// New UDP "connection"
		sm.sessions[key] = &Session{
			ID:        key,
			Protocol:  ProtoUDP,
			Src:       src,
			Dst:       dst,
			Iface:     iface,
			IPVersion: ipVersion,
			StartTime: time.Now(),
			LastSeen:  time.Now(),
			ByteCount: int64(length),
		}

		srcIP, srcPortNum := parseAddr(src)
		dstIP, dstPortNum := parseAddr(dst)

		if service != "" {
			sm.logger.Info("[UDP START]",
				"iface", iface,
				"src", src,
				"dst", dst,
				"service", service,
			)
		} else {
			sm.logger.Info("[UDP START]",
				"iface", iface,
				"src", src,
				"dst", dst,
			)
		}

		if sm.db != nil {
			sm.db.InsertEvent(&database.NetworkEvent{
				Timestamp: time.Now(),
				EventType: database.EventUDPStart,
				Interface: iface,
				IPVersion: ipVersion,
				SrcIP:     srcIP,
				SrcPort:   srcPortNum,
				DstIP:     dstIP,
				DstPort:   dstPortNum,
				Protocol:  service,
			})
		}
	} else {
		// Update existing session
		session.LastSeen = time.Now()
		session.ByteCount += int64(length)
	}
}
// TrackICMP handles ICMP packets
// icmpPayload contains the original packet header for destination unreachable messages
func (sm *SessionManager) TrackICMP(iface, src, dst string, icmpType, icmpCode uint8, length int, isIPv6 bool, icmpPayload []byte) {
	if !sm.shouldLog("icmp") {
		return
	}

	// Check NDP exclusion (ICMPv6 types 133-137 are NDP)
	if sm.exclusions["ndp"] && isIPv6 {
		if icmpType >= 133 && icmpType <= 137 {
			return
		}
	}

	// Check destination unreachable exclusion
	if sm.exclusions["unreachable"] {
		if (!isIPv6 && icmpType == 3) || (isIPv6 && icmpType == 1) {
			return
		}
	}

	// For ICMP destination unreachable, check if the original packet's port is excluded
	// ICMPv4 type 3 code 3 = Port Unreachable, ICMPv6 type 1 code 4 = Port Unreachable
	if len(sm.excludePorts) > 0 {
		if (!isIPv6 && icmpType == 3 && icmpCode == 3) || (isIPv6 && icmpType == 1 && icmpCode == 4) {
			port := extractPortFromICMPPayload(icmpPayload, isIPv6)
			if port > 0 && sm.excludePorts[port] {
				return
			}
		}
	}

	key := fmt.Sprintf("ICMP:%s->%s", src, dst)

	sm.mutex.Lock()
	defer sm.mutex.Unlock()

	session, exists := sm.sessions[key]

	ipVersion := uint8(4)
	if isIPv6 {
		ipVersion = 6
	}

	if !exists {
		sm.sessions[key] = &Session{
			ID:        key,
			Protocol:  ProtoICMP,
			Src:       src,
			Dst:       dst,
			Iface:     iface,
			IPVersion: ipVersion,
			StartTime: time.Now(),
			LastSeen:  time.Now(),
			ByteCount: int64(length),
		}

		desc := icmpTypeDescription(icmpType, isIPv6)
		sm.logger.Info("[ICMP]",
			"iface", iface,
			"src", src,
			"dst", dst,
			"type", icmpType,
			"code", icmpCode,
			"desc", desc,
		)

		if sm.db != nil {
			sm.db.InsertEvent(&database.NetworkEvent{
				Timestamp: time.Now(),
				EventType: database.EventICMP,
				Interface: iface,
				IPVersion: ipVersion,
				SrcIP:     src,
				DstIP:     dst,
				ICMPType:  icmpType,
				ICMPCode:  icmpCode,
				ICMPDesc:  desc,
			})
		}
	} else {
		session.LastSeen = time.Now()
		session.ByteCount += int64(length)
	}
}

// TrackDNS logs DNS queries and caches resolved IPs
func (sm *SessionManager) TrackDNS(iface, src, dst string, queries []string, isResponse bool, resolvedIPs []string, cnames []string, isIPv6 bool) {
	if !sm.shouldLog("dns") {
		return
	}

	ipVersion := uint8(4)
	if isIPv6 {
		ipVersion = 6
	}

	queryType := "QUERY"
	if isResponse {
		queryType = "RESPONSE"

		// Cache the resolved IPs for hostname lookup
		if len(queries) > 0 && len(resolvedIPs) > 0 {
			hostname := queries[0] // Use first query name as hostname
			sm.dnsCacheMutex.Lock()
			for _, ip := range resolvedIPs {
				sm.dnsCache[ip] = &DNSCacheEntry{
					Hostname:  hostname,
					Timestamp: time.Now(),
				}
			}
			sm.dnsCacheMutex.Unlock()
		}
	}

	srcIP, srcPort := parseAddr(src)
	dstIP, dstPort := parseAddr(dst)

	for _, q := range queries {
		answersStr := ""
		cnamesStr := ""
		if isResponse && len(resolvedIPs) > 0 {
			answersStr = strings.Join(resolvedIPs, ",")
			if len(cnames) > 0 {
				cnamesStr = strings.Join(cnames, ",")
				sm.logger.Info("[DNS]",
					"iface", iface,
					"type", queryType,
					"src", src,
					"dst", dst,
					"domain", q,
					"cnames", cnames,
					"answers", resolvedIPs,
				)
			} else {
				sm.logger.Info("[DNS]",
					"iface", iface,
					"type", queryType,
					"src", src,
					"dst", dst,
					"domain", q,
					"answers", resolvedIPs,
				)
			}
		} else {
			sm.logger.Info("[DNS]",
				"iface", iface,
				"type", queryType,
				"src", src,
				"dst", dst,
				"domain", q,
			)
		}

		if sm.db != nil {
			sm.db.InsertEvent(&database.NetworkEvent{
				Timestamp:  time.Now(),
				EventType:  database.EventDNS,
				Interface:  iface,
				IPVersion:  ipVersion,
				SrcIP:      srcIP,
				SrcPort:    srcPort,
				DstIP:      dstIP,
				DstPort:    dstPort,
				DNSQuery:   q,
				DNSType:    queryType,
				DNSAnswers: answersStr,
				DNSCNAMEs:  cnamesStr,
			})
		}
	}
}

// TrackTLSHandshake logs TLS SNI (Server Name Indication)
func (sm *SessionManager) TrackTLSHandshake(iface, src, dst, sni string, isIPv6 bool) {
	if !sm.shouldLog("tls") {
		return
	}

	ipVersion := uint8(4)
	if isIPv6 {
		ipVersion = 6
	}

	sm.logger.Info("[TLS SNI]",
		"iface", iface,
		"src", src,
		"dst", dst,
		"server_name", sni,
	)

	srcIP, srcPort := parseAddr(src)
	dstIP, dstPort := parseAddr(dst)

	if sm.db != nil {
		sm.db.InsertEvent(&database.NetworkEvent{
			Timestamp: time.Now(),
			EventType: database.EventTLSSNI,
			Interface: iface,
			IPVersion: ipVersion,
			SrcIP:     srcIP,
			SrcPort:   srcPort,
			DstIP:     dstIP,
			DstPort:   dstPort,
			TLSSNI:    sni,
		})
	}
}

// cleanupLoop removes stale connections (the "Ghost" problem solution)
func (sm *SessionManager) cleanupLoop() {
	ticker := time.NewTicker(sm.cleanupInterval)
	defer ticker.Stop()

	for {
		select {
		case <-sm.stopChan:
			return
		case <-ticker.C:
			sm.mutex.Lock()
			threshold := time.Now().Add(-sm.sessionTimeout)
			for key, session := range sm.sessions {
				if session.LastSeen.Before(threshold) {
					duration := session.LastSeen.Sub(session.StartTime)
					srcIP, srcPort := parseAddr(session.Src)
					dstIP, dstPort := parseAddr(session.Dst)

					// Log as UDP END for UDP sessions, TIMEOUT for others
					if session.Protocol == ProtoUDP {
						sm.logger.Info("[UDP END]",
							"iface", session.Iface,
							"src", session.Src,
							"dst", session.Dst,
							"duration", duration.Round(time.Millisecond),
							"bytes", session.ByteCount,
						)

						if sm.db != nil {
							sm.db.InsertEvent(&database.NetworkEvent{
								Timestamp: time.Now(),
								EventType: database.EventUDPEnd,
								Interface: session.Iface,
								IPVersion: session.IPVersion,
								SrcIP:     srcIP,
								SrcPort:   srcPort,
								DstIP:     dstIP,
								DstPort:   dstPort,
								Duration:  int64(duration.Milliseconds()),
								ByteCount: session.ByteCount,
							})
						}
					} else {
						sm.logger.Info("[TIMEOUT]",
							"protocol", session.Protocol,
							"iface", session.Iface,
							"src", session.Src,
							"dst", session.Dst,
							"duration", duration.Round(time.Millisecond),
							"bytes", session.ByteCount,
						)

						if sm.db != nil {
							sm.db.InsertEvent(&database.NetworkEvent{
								Timestamp: time.Now(),
								EventType: database.EventTimeout,
								Interface: session.Iface,
								IPVersion: session.IPVersion,
								SrcIP:     srcIP,
								SrcPort:   srcPort,
								DstIP:     dstIP,
								DstPort:   dstPort,
								Protocol:  string(session.Protocol),
								Duration:  int64(duration.Milliseconds()),
								ByteCount: session.ByteCount,
							})
						}
					}
					delete(sm.sessions, key)
				}
			}
			sm.mutex.Unlock()

			// Also clean up old DNS cache entries (older than 10 minutes)
			sm.dnsCacheMutex.Lock()
			dnsThreshold := time.Now().Add(-10 * time.Minute)
			for ip, entry := range sm.dnsCache {
				if entry.Timestamp.Before(dnsThreshold) {
					delete(sm.dnsCache, ip)
				}
			}
			sm.dnsCacheMutex.Unlock()
		}
	}
}

// lookupDNSCache returns the hostname and age for a given IP
func (sm *SessionManager) lookupDNSCache(ip string) (string, time.Duration) {
	sm.dnsCacheMutex.RLock()
	defer sm.dnsCacheMutex.RUnlock()

	if entry, ok := sm.dnsCache[ip]; ok {
		return entry.Hostname, time.Since(entry.Timestamp)
	}
	return "", 0
}

// extractIPFromAddr extracts IP from "[ip]:port" format
func extractIPFromAddr(addr string) string {
	// Handle "[ip]:port" format
	if strings.HasPrefix(addr, "[") {
		end := strings.Index(addr, "]")
		if end > 1 {
			return addr[1:end]
		}
	}
	// Handle "ip:port" format (shouldn't happen but just in case)
	if idx := strings.LastIndex(addr, ":"); idx > 0 {
		return addr[:idx]
	}
	return addr
}

// parseAddr extracts IP and port from "[ip]:port" format
func parseAddr(addr string) (string, uint16) {
	host, portStr, err := net.SplitHostPort(addr)
	if err != nil {
		return addr, 0
	}
	var port uint16
	fmt.Sscanf(portStr, "%d", &port)
	return host, port
}

// GetActiveSessions returns a snapshot of active sessions (for debugging/stats)
func (sm *SessionManager) GetActiveSessions() []Session {
	sm.mutex.RLock()
	defer sm.mutex.RUnlock()

	sessions := make([]Session, 0, len(sm.sessions))
	for _, s := range sm.sessions {
		sessions = append(sessions, *s)
	}
	return sessions
}

// icmpTypeDescription returns human-readable ICMP type
func icmpTypeDescription(icmpType uint8, isIPv6 bool) string {
	if isIPv6 {
		return icmpv6TypeDescription(icmpType)
	}
	return icmpv4TypeDescription(icmpType)
}

// icmpv4TypeDescription returns human-readable ICMPv4 type
func icmpv4TypeDescription(icmpType uint8) string {
	switch icmpType {
	case 0:
		return "Echo Reply"
	case 3:
		return "Destination Unreachable"
	case 5:
		return "Redirect"
	case 8:
		return "Echo Request (Ping)"
	case 11:
		return "Time Exceeded"
	default:
		return fmt.Sprintf("Type %d", icmpType)
	}
}

// icmpv6TypeDescription returns human-readable ICMPv6 type
func icmpv6TypeDescription(icmpType uint8) string {
	switch icmpType {
	case 1:
		return "Destination Unreachable"
	case 2:
		return "Packet Too Big"
	case 3:
		return "Time Exceeded"
	case 128:
		return "Echo Request (Ping)"
	case 129:
		return "Echo Reply"
	case 130:
		return "Multicast Listener Query"
	case 131:
		return "Multicast Listener Report"
	case 133:
		return "Router Solicitation"
	case 134:
		return "Router Advertisement"
	case 135:
		return "Neighbor Solicitation"
	case 136:
		return "Neighbor Advertisement"
	case 143:
		return "MLDv2 Report"
	default:
		return fmt.Sprintf("Type %d", icmpType)
	}
}

// extractPortFromICMPPayload extracts the destination port from the original packet
// embedded in an ICMP destination unreachable message
// ICMP payload contains: Original IP header + first 8 bytes of original datagram (UDP/TCP header)
func extractPortFromICMPPayload(payload []byte, isIPv6 bool) uint16 {
	if len(payload) < 8 {
		return 0
	}

	var ipHeaderLen int
	if isIPv6 {
		// IPv6 header is fixed 40 bytes, but ICMP payload starts after ICMP header
		// The payload should already be the original packet (IP header + transport)
		ipHeaderLen = 40
	} else {
		// IPv4: IHL field (lower 4 bits of first byte) * 4
		if len(payload) < 1 {
			return 0
		}
		ipHeaderLen = int(payload[0]&0x0f) * 4
	}

	// After IP header, we have the transport header
	// UDP header: src port (2 bytes) + dst port (2 bytes)
	// We want the destination port (bytes 2-3 of transport header)
	transportOffset := ipHeaderLen
	if len(payload) < transportOffset+4 {
		return 0
	}

	// Destination port is at offset 2-3 of UDP/TCP header
	dstPort := binary.BigEndian.Uint16(payload[transportOffset+2 : transportOffset+4])
	return dstPort
}

// identifyUDPService returns service name based on port
func identifyUDPService(srcPort, dstPort uint16) string {
	// Check destination port first, then source
	ports := []uint16{dstPort, srcPort}
	for _, port := range ports {
		switch port {
		case 53:
			return "DNS"
		case 443:
			return "QUIC"
		case 80:
			return "HTTP/UDP"
		case 123:
			return "NTP"
		case 500, 4500:
			return "IKE/IPsec"
		case 51820:
			return "WireGuard"
		case 41641:
			return "Tailscale"
		case 3478, 3479, 5349:
			return "STUN/TURN"
		case 5353:
			return "mDNS"
		case 1900:
			return "SSDP/UPnP"
		case 5351:
			return "NAT-PMP"
		case 6881, 6882, 6883, 6884, 6885, 6886, 6887, 6888, 6889:
			return "BitTorrent"
		}
	}
	return ""
}

// ParseDNSResponse extracts domain names, resolved IPs, and CNAMEs from DNS response
func ParseDNSResponse(payload []byte) (queries []string, resolvedIPs []string, cnames []string, isResponse bool) {
	if len(payload) < 12 {
		return nil, nil, nil, false
	}

	// DNS header: ID(2) + Flags(2) + QDCOUNT(2) + ANCOUNT(2) + NSCOUNT(2) + ARCOUNT(2)
	flags := binary.BigEndian.Uint16(payload[2:4])
	isResponse = (flags & 0x8000) != 0
	qdCount := binary.BigEndian.Uint16(payload[4:6])
	anCount := binary.BigEndian.Uint16(payload[6:8])

	offset := 12 // Start of questions section

	// Parse questions
	for i := uint16(0); i < qdCount && offset < len(payload); i++ {
		name, newOffset := parseDNSName(payload, offset)
		if name != "" {
			queries = append(queries, name)
		}
		offset = newOffset + 4 // Skip QTYPE(2) + QCLASS(2)
	}

	// Parse answers (only if response)
	if isResponse && anCount > 0 {
		for i := uint16(0); i < anCount && offset < len(payload); i++ {
			// Skip name (might be compressed)
			_, newOffset := parseDNSName(payload, offset)
			offset = newOffset

			if offset+10 > len(payload) {
				break
			}

			rtype := binary.BigEndian.Uint16(payload[offset : offset+2])
			// Skip rclass(2)
			offset += 4
			// Skip TTL(4)
			offset += 4
			rdlength := binary.BigEndian.Uint16(payload[offset : offset+2])
			offset += 2

			if offset+int(rdlength) > len(payload) {
				break
			}

			// A record (IPv4)
			if rtype == 1 && rdlength == 4 {
				ip := net.IP(payload[offset : offset+4])
				resolvedIPs = append(resolvedIPs, ip.String())
			}
			// AAAA record (IPv6)
			if rtype == 28 && rdlength == 16 {
				ip := net.IP(payload[offset : offset+16])
				resolvedIPs = append(resolvedIPs, ip.String())
			}
			// CNAME record
			if rtype == 5 {
				cname, _ := parseDNSName(payload, offset)
				if cname != "" {
					cnames = append(cnames, cname)
				}
			}

			offset += int(rdlength)
		}
	}

	return queries, resolvedIPs, cnames, isResponse
}

// ParseDNSQueries extracts domain names from DNS layer (legacy, use ParseDNSResponse instead)
func ParseDNSQueries(payload []byte) ([]string, bool) {
	queries, _, _, isResponse := ParseDNSResponse(payload)
	return queries, isResponse
}

// parseDNSName parses a DNS name from the packet
func parseDNSName(payload []byte, offset int) (string, int) {
	var name string
	for offset < len(payload) {
		length := int(payload[offset])
		if length == 0 {
			offset++
			break
		}
		// Check for compression pointer
		if length&0xC0 == 0xC0 {
			if offset+1 >= len(payload) {
				break
			}
			// Follow pointer (not implementing full recursion for simplicity)
			offset += 2
			break
		}
		offset++
		if offset+length > len(payload) {
			break
		}
		if name != "" {
			name += "."
		}
		name += string(payload[offset : offset+length])
		offset += length
	}
	return name, offset
}

// ParseTLSSNI extracts Server Name Indication from TLS ClientHello
func ParseTLSSNI(payload []byte) string {
	// Minimum TLS record: 5 bytes header + some content
	if len(payload) < 43 {
		return ""
	}

	// Check TLS Handshake record type (0x16)
	if payload[0] != 0x16 {
		return ""
	}

	// Check for ClientHello (handshake type 0x01)
	// TLS record header: Type(1) + Version(2) + Length(2)
	// Handshake header: Type(1) + Length(3)
	if payload[5] != 0x01 {
		return ""
	}

	// Skip to extensions
	// ClientHello: Version(2) + Random(32) + SessionID(1+var) + CipherSuites(2+var) + Compression(1+var)
	offset := 5 + 4 // TLS header + Handshake header

	// Skip version
	offset += 2

	// Skip random
	offset += 32

	// Skip session ID
	if offset >= len(payload) {
		return ""
	}
	sessionIDLen := int(payload[offset])
	offset += 1 + sessionIDLen

	// Skip cipher suites
	if offset+2 > len(payload) {
		return ""
	}
	cipherSuitesLen := int(binary.BigEndian.Uint16(payload[offset : offset+2]))
	offset += 2 + cipherSuitesLen

	// Skip compression methods
	if offset >= len(payload) {
		return ""
	}
	compressionLen := int(payload[offset])
	offset += 1 + compressionLen

	// Extensions length
	if offset+2 > len(payload) {
		return ""
	}
	extensionsLen := int(binary.BigEndian.Uint16(payload[offset : offset+2]))
	offset += 2

	// Parse extensions looking for SNI (type 0x0000)
	endOffset := offset + extensionsLen
	if endOffset > len(payload) {
		endOffset = len(payload)
	}

	for offset+4 <= endOffset {
		extType := binary.BigEndian.Uint16(payload[offset : offset+2])
		extLen := int(binary.BigEndian.Uint16(payload[offset+2 : offset+4]))
		offset += 4

		if offset+extLen > endOffset {
			break
		}

		// SNI extension type is 0x0000
		if extType == 0x0000 && extLen > 5 {
			// SNI list length (2) + name type (1) + name length (2) + name
			nameLen := int(binary.BigEndian.Uint16(payload[offset+3 : offset+5]))
			if offset+5+nameLen <= endOffset {
				return string(payload[offset+5 : offset+5+nameLen])
			}
		}

		offset += extLen
	}

	return ""
}
