// Generated by Copilot
//go:build linux
// +build linux

package capture

import (
	"encoding/binary"
	"fmt"
	"net"
	"strings"
	"syscall"
	"time"

	"github.com/abja/net-watcher/internal/database"
)

// DNSSniffer handles DNS packet capture using raw AF_PACKET sockets (Linux only)
type DNSSniffer struct {
	fd         int
	ifaceName  string
	ifaceIndex int
	eventChan  chan database.DNSEvent
	batchSize  int
	debug      bool
	stopChan   chan struct{}
}

// NewDNSSniffer creates a new DNS sniffer for specified interface
func NewDNSSniffer(iface string, batchSize int, debug bool) (*DNSSniffer, error) {
	// Get interface by name
	ifaceObj, err := net.InterfaceByName(iface)
	if err != nil {
		return nil, fmt.Errorf("failed to get interface %s: %w", iface, err)
	}

	// Create raw socket for packet capture (AF_PACKET, SOCK_RAW, ETH_P_IP)
	fd, err := syscall.Socket(syscall.AF_PACKET, syscall.SOCK_RAW, int(htons(syscall.ETH_P_IP)))
	if err != nil {
		return nil, fmt.Errorf("failed to create raw socket: %w (requires CAP_NET_RAW)", err)
	}

	// Bind to specific interface
	addr := syscall.SockaddrLinklayer{
		Protocol: htons(syscall.ETH_P_IP),
		Ifindex:  ifaceObj.Index,
	}
	if err := syscall.Bind(fd, &addr); err != nil {
		syscall.Close(fd)
		return nil, fmt.Errorf("failed to bind to interface %s: %w", iface, err)
	}

	sniffer := &DNSSniffer{
		fd:         fd,
		ifaceName:  iface,
		ifaceIndex: ifaceObj.Index,
		eventChan:  make(chan database.DNSEvent, 1000),
		batchSize:  batchSize,
		debug:      debug,
		stopChan:   make(chan struct{}),
	}

	return sniffer, nil
}

// htons converts a short (uint16) from host to network byte order
func htons(i uint16) uint16 {
	return (i<<8)&0xff00 | i>>8
}

// Start begins packet capture
func (d *DNSSniffer) Start() error {
	if d.debug {
		fmt.Printf("Starting DNS capture on interface %s (AF_PACKET)\n", d.ifaceName)
	}

	// Start packet processing in a goroutine
	go d.processPackets()

	return nil
}

// Stop stops packet capture
func (d *DNSSniffer) Stop() {
	close(d.stopChan)
	if d.fd > 0 {
		syscall.Close(d.fd)
	}
	close(d.eventChan)
}

// GetEventChannel returns channel for DNS events
func (d *DNSSniffer) GetEventChannel() <-chan database.DNSEvent {
	return d.eventChan
}

// processPackets captures and processes packets from raw socket
func (d *DNSSniffer) processPackets() {
	buf := make([]byte, 65536)

	for {
		select {
		case <-d.stopChan:
			return
		default:
			// Set read timeout to allow checking stop channel
			syscall.SetsockoptTimeval(d.fd, syscall.SOL_SOCKET, syscall.SO_RCVTIMEO, &syscall.Timeval{Sec: 1})

			n, _, err := syscall.Recvfrom(d.fd, buf, 0)
			if err != nil {
				if err == syscall.EAGAIN || err == syscall.EWOULDBLOCK {
					continue // Timeout, check stop channel
				}
				if d.debug {
					fmt.Printf("Error reading packet: %v\n", err)
				}
				continue
			}

			if n < 14 { // Minimum Ethernet header size
				continue
			}

			event, err := d.parsePacket(buf[:n])
			if err != nil {
				if d.debug {
					fmt.Printf("Failed to parse packet: %v\n", err)
				}
				continue
			}

			if event != nil {
				select {
				case d.eventChan <- *event:
				default:
					if d.debug {
						fmt.Println("Event channel full, dropping packet")
					}
				}
			}
		}
	}
}

// parsePacket extracts DNS information from a raw packet
func (d *DNSSniffer) parsePacket(data []byte) (*database.DNSEvent, error) {
	// Skip Ethernet header (14 bytes)
	if len(data) < 14 {
		return nil, fmt.Errorf("packet too short for Ethernet header")
	}

	// Check EtherType (bytes 12-13)
	etherType := binary.BigEndian.Uint16(data[12:14])

	var ipStart int
	var srcIP, dstIP string

	switch etherType {
	case 0x0800: // IPv4
		ipStart = 14
		if len(data) < ipStart+20 {
			return nil, fmt.Errorf("packet too short for IPv4 header")
		}

		// Parse IPv4 header
		ipHeaderLen := int(data[ipStart]&0x0F) * 4
		if len(data) < ipStart+ipHeaderLen {
			return nil, fmt.Errorf("invalid IPv4 header length")
		}

		// Check protocol (byte 9 of IP header) - should be UDP (17)
		protocol := data[ipStart+9]
		if protocol != 17 {
			return nil, fmt.Errorf("not UDP packet")
		}

		srcIP = fmt.Sprintf("%d.%d.%d.%d", data[ipStart+12], data[ipStart+13], data[ipStart+14], data[ipStart+15])
		dstIP = fmt.Sprintf("%d.%d.%d.%d", data[ipStart+16], data[ipStart+17], data[ipStart+18], data[ipStart+19])

		// Move to UDP header
		udpStart := ipStart + ipHeaderLen
		if len(data) < udpStart+8 {
			return nil, fmt.Errorf("packet too short for UDP header")
		}

		// Check destination port (bytes 2-3 of UDP header)
		dstPort := binary.BigEndian.Uint16(data[udpStart+2 : udpStart+4])
		if dstPort != 53 {
			return nil, fmt.Errorf("not DNS packet (port %d)", dstPort)
		}

		// Parse DNS payload
		dnsStart := udpStart + 8
		return d.parseDNS(data[dnsStart:], srcIP, dstIP, len(data))

	case 0x86DD: // IPv6
		ipStart = 14
		if len(data) < ipStart+40 {
			return nil, fmt.Errorf("packet too short for IPv6 header")
		}

		// Check next header (byte 6 of IPv6 header) - should be UDP (17)
		nextHeader := data[ipStart+6]
		if nextHeader != 17 {
			return nil, fmt.Errorf("not UDP packet")
		}

		srcIP = net.IP(data[ipStart+8 : ipStart+24]).String()
		dstIP = net.IP(data[ipStart+24 : ipStart+40]).String()

		// Move to UDP header (IPv6 header is fixed 40 bytes)
		udpStart := ipStart + 40
		if len(data) < udpStart+8 {
			return nil, fmt.Errorf("packet too short for UDP header")
		}

		// Check destination port
		dstPort := binary.BigEndian.Uint16(data[udpStart+2 : udpStart+4])
		if dstPort != 53 {
			return nil, fmt.Errorf("not DNS packet (port %d)", dstPort)
		}

		// Parse DNS payload
		dnsStart := udpStart + 8
		return d.parseDNS(data[dnsStart:], srcIP, dstIP, len(data))

	default:
		return nil, fmt.Errorf("unsupported EtherType: 0x%04x", etherType)
	}
}

// parseDNS parses DNS query from payload
func (d *DNSSniffer) parseDNS(data []byte, srcIP, dstIP string, packetSize int) (*database.DNSEvent, error) {
	if len(data) < 12 {
		return nil, fmt.Errorf("DNS payload too short")
	}

	// DNS header flags (bytes 2-3)
	flags := binary.BigEndian.Uint16(data[2:4])
	qr := (flags >> 15) & 0x1

	// Only process queries (QR=0)
	if qr != 0 {
		return nil, nil
	}

	// Question count (bytes 4-5)
	qdCount := binary.BigEndian.Uint16(data[4:6])
	if qdCount == 0 {
		return nil, fmt.Errorf("no questions in DNS query")
	}

	// Parse first question (starts at byte 12)
	offset := 12
	domain, newOffset, err := parseDNSName(data, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to parse domain name: %w", err)
	}

	if len(data) < newOffset+4 {
		return nil, fmt.Errorf("DNS question section too short")
	}

	// Query type (2 bytes after domain name)
	qtype := binary.BigEndian.Uint16(data[newOffset : newOffset+2])

	event := database.DNSEvent{
		Timestamp:  time.Now(),
		SourceIP:   srcIP,
		DestIP:     dstIP,
		DomainName: domain,
		RecordType: dnsTypeToString(qtype),
		Interface:  d.ifaceName,
		PacketSize: packetSize,
	}

	if d.debug {
		fmt.Printf("DNS Query: %s (%s) from %s to %s\n",
			event.DomainName, event.RecordType, event.SourceIP, event.DestIP)
	}

	return &event, nil
}

// parseDNSName parses a DNS domain name from the packet
func parseDNSName(data []byte, offset int) (string, int, error) {
	var parts []string
	jumped := false
	originalOffset := offset
	maxOffset := offset

	for {
		if offset >= len(data) {
			return "", 0, fmt.Errorf("offset out of bounds")
		}

		length := int(data[offset])

		// Check for pointer (compression)
		if length&0xC0 == 0xC0 {
			if offset+1 >= len(data) {
				return "", 0, fmt.Errorf("invalid pointer")
			}
			pointer := int(binary.BigEndian.Uint16(data[offset:offset+2])) & 0x3FFF
			if !jumped {
				maxOffset = offset + 2
			}
			offset = pointer
			jumped = true
			continue
		}

		if length == 0 {
			if !jumped {
				maxOffset = offset + 1
			}
			break
		}

		offset++
		if offset+length > len(data) {
			return "", 0, fmt.Errorf("label extends beyond packet")
		}

		parts = append(parts, string(data[offset:offset+length]))
		offset += length

		if !jumped {
			maxOffset = offset
		}

		// Safety check to prevent infinite loops
		if offset-originalOffset > 255 {
			return "", 0, fmt.Errorf("domain name too long")
		}
	}

	return strings.Join(parts, "."), maxOffset, nil
}

// dnsTypeToString converts DNS type to string representation
func dnsTypeToString(dnsType uint16) string {
	switch dnsType {
	case 1:
		return "A"
	case 28:
		return "AAAA"
	case 5:
		return "CNAME"
	case 15:
		return "MX"
	case 2:
		return "NS"
	case 12:
		return "PTR"
	case 6:
		return "SOA"
	case 16:
		return "TXT"
	case 33:
		return "SRV"
	case 257:
		return "CAA"
	case 65:
		return "HTTPS"
	default:
		return fmt.Sprintf("TYPE_%d", dnsType)
	}
}

// GetEgressInterfaces returns list of interfaces that can be used for egress traffic
func GetEgressInterfaces() ([]string, error) {
	interfaces, err := net.Interfaces()
	if err != nil {
		return nil, fmt.Errorf("failed to get network interfaces: %w", err)
	}

	var egressInterfaces []string

	for _, iface := range interfaces {
		// Skip loopback and down interfaces
		if iface.Flags&net.FlagLoopback != 0 || iface.Flags&net.FlagUp == 0 {
			continue
		}

		// Skip interfaces without IP addresses
		addrs, err := iface.Addrs()
		if err != nil || len(addrs) == 0 {
			continue
		}

		// Check if interface has a non-local IP address
		hasEgressIP := false
		for _, addr := range addrs {
			ipNet, ok := addr.(*net.IPNet)
			if !ok {
				continue
			}

			// Skip localhost and link-local addresses
			if ipNet.IP.IsLoopback() || ipNet.IP.IsLinkLocalUnicast() {
				continue
			}

			// Check if it's a routable IP
			if !ipNet.IP.IsPrivate() || ipNet.IP.IsGlobalUnicast() {
				hasEgressIP = true
				break
			}
		}

		if hasEgressIP {
			// Filter out common non-egress interfaces
			if !isNonEgressInterface(iface.Name) {
				egressInterfaces = append(egressInterfaces, iface.Name)
			}
		}
	}

	return egressInterfaces, nil
}

// isNonEgressInterface checks if interface name suggests it's not for egress
func isNonEgressInterface(name string) bool {
	nonEgressPatterns := []string{
		"docker", "virbr", "veth", "br-", "kube", "flannel",
		"cni", "tun", "tap", "vbox", "utun", "awdl",
	}

	lowerName := strings.ToLower(name)
	for _, pattern := range nonEgressPatterns {
		if strings.Contains(lowerName, pattern) {
			return true
		}
	}

	return false
}

// ValidateInterface checks if an interface exists and is up
func ValidateInterface(ifaceName string) error {
	interfaces, err := net.Interfaces()
	if err != nil {
		return fmt.Errorf("failed to get network interfaces: %w", err)
	}

	for _, iface := range interfaces {
		if iface.Name == ifaceName {
			if iface.Flags&net.FlagUp == 0 {
				return fmt.Errorf("interface %s is down", ifaceName)
			}
			return nil
		}
	}

	return fmt.Errorf("interface %s not found", ifaceName)
}
